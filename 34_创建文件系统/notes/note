块：
    块是文件系统的读写(管理)单位，我们在硬盘的分区(partition)上构建文件系统，首先将分区分块，以实现文件系统对分区的管理。
inode:
    inode是一个数据结构，存储于硬盘分区中，用于描述一个文件的元信息如：一个文件的数据块由哪些blocks中的块(block)构成、文件大小、文件所有者、访问权限……
    inode table：inode table即inode表，是inode型数据结构数组，硬盘上的每个文件由一个inode描述，因此inode表越大(inode表项越多)理论上可存储的文件越多。
    硬盘文件由块构成，inode表中为每个文件建立一个索引表，用于索引每个文件的所有数据块的位置。
    当文件很大时，索引表项增多，索引表会变得很大，因此索引表由直接块指针(指向一个数据块)、一级间接块指针(指向一个索引表(直接块指针数组))、二级间接块指针……

分区存储空间组织：
    blocks：磁盘分区上大部分块block用于存储用户数据文件，这部分块(data block)构成数据域(data region).
    inodes：硬盘用于存储文件，块是文件系统的读写单位，因此每个文件由若干个块构成，为追踪分区中每个文件(多个块构成)的信息(metadata)，
        文件系统使用inode描述一个文件的元信息，我们还需在分区中占用部分块用于存储inode，这部分空间称为inode table。
    块位图：为了追踪硬盘上数据域中哪些块已被分配(分配给文件)、哪些是空闲(创建文件时可被分配的块)，我们使用位图bitmap来描述管理数据域中的块，位图值1表示块被分配、0表示未分配。
    inode位图：同理，为追踪inode表中哪些表项被分配或未分配，我们还需要使用位图管理inode table。
    超级块(superblock)：定义文件系统、描述文件系统的信息：比如本分区文件系统含有多少个inode、多少个data block、inode表起始位置、我们的文件系统的标识(魔数)……

分区组成：
    引导块(EBR、OBR)、超级块、i结点位图、块位图、i结点、块
    我们的文件系统每块一个扇区，超级块在分区lba+1扇区上、i节点位图在lba+2……
目录：
    硬盘上目录也是文件，即目录也占用inode、数据块，目录的数据块由<目录下文件的inode,"文件名字符串">entry目录项构成，这些表项描述该目录下的文件。
    每个目录下默认有两个目录项，"."和".."  "."表示当前目录 ".."该目录的上级目录。

创建文件系统：
    注：为实现方便，我们将块规定为一个扇区大小。
    一、创建超级块、inode结点、目录项数据结构。
        1.超级块：
            我们在磁盘驱动ide.h中定义分区数据结构时已经提前定义了：
            struct super_block* sb;     //描述分区超级块
            struct bitmap inode_bitmap; //i结点位图，每个i结点对应一个文件属性
            struct bitmap block_bitmap; //逻辑块位图
            三个数据结构指针。我们在fs文件夹下定义必要的数据结构。
        2.inode：
            我们的文件系统支持两种文件：普通文件、目录文件。
        3.目录项：
            描述目录结构。
        4.定义块大小 分区支持的inode个数等信息。

    二、创建文件系统，使用初始化的数据结构格式化硬盘的扇区，即格式化。
        Ⅰ初始化：
            1.将超级块写入该分区的第一扇区
            2.将块位图初始化并写入硬盘分区的块位图所在块
            3.将inode位图写入硬盘对应扇区
            4.将inode数组初始化，写入硬盘
            5.将根目录初始化，并将目录项写入根目录所在的sb.data_start_lba
        Ⅱ在硬盘上搜索文件系统，若没有则格式化分区创建文件系统，filesys_init()
            运行测试：hd80M.img初始时只有分区，不含文件系统，当运行时，filesys_init()会检查该硬盘上各分区是否有文件系统，
            若没有则对硬盘格式化，形成文件系统。

    三、挂载硬盘分区，即内核按照我们规定的方式(我们实现的文件系统)读取分区的位图和inode等信息到内存，追踪硬盘资源变化，
        若有写操作，及时将内存中的inode、位图等信息同步写道硬盘分区中。
        
        挂载分区分析：mount_partition(struct list_elem* pelem,char* arg):
        我们在ide.h中定义struct partition时定义struct list_elem part_tag成员，并在ide_init()调用partition_scan()
        该函数递归扫描硬盘的分区表信息，并将获取的分区通过定义的全局结构struct list partition_list，链接所有分区。
        故形参list_elem* pelem为该链表中某个分区指针。arg为分区名字符串。


        
