线程 main、k_kernel_a、k_kernel_b均通过向显存写数据实现put_str();
这三个线程未实现对显存这类共享资源的互斥访问导致运行时出现General Protection Fault
为实现多线程在任务切换时仍能实现对共享资源的互斥访问。
我们通过锁来实现多个线程对共享资源的互斥访问

锁是二元信号量 0 ，1
0表示锁已被占有
1表示锁已经释放

当各个进程在进入自己的临界区时通过锁来实现互斥访问临界资源。

将终端 console 视为临界资源，并为其设置一个锁
当某个线程想要输出时，要申请终端对应的锁
若申请成功：执行其临界区程序，释放锁、若有进程在该锁休眠则唤醒一个休眠进程。                                                                                                                                                                                                        
若申请失败：进程阻塞在该锁对应的休眠队列中，进行调度、将当前线程换下处理器。

实现：
    申请锁：lock_acquire                    sync.h
        信号量P操作：sema_down              
            线程阻塞：thread_block          thread.h
    释放锁：lock_release
        信号量V操作：sema_up
            线程唤醒：thread_unblock